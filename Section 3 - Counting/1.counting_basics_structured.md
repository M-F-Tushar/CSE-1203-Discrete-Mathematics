# 6.1 The Basics of Counting - Comprehensive Study Guide

## 6.1.1 Introduction

**Core Question**: Suppose that a password on a computer system consists of six, seven, or eight characters. Each character must be a digit or a letter of the alphabet. Each password must contain at least one digit. How many such passwords are there?

**Why Counting Matters**:
- Determining probabilities of discrete events
- Analyzing algorithm time complexity
- Solving combinatorial problems in mathematics and computer science

---

## 6.1.2 Basic Counting Principles

### The Product Rule

**Definition**: If a procedure can be broken down into a sequence of two tasks, where there are n₁ ways to do the first task and n₂ ways to do the second task (for each way of doing the first), then there are n₁ × n₂ ways to do the procedure.

**Extended Version**: For tasks T₁, T₂, ..., Tₘ with n₁, n₂, ..., nₘ ways respectively, there are n₁ × n₂ × ... × nₘ ways total.

#### Examples Using Product Rule

**Example 1: Office Assignment**
- **Problem**: A company with 2 employees (Sanchez and Patel) has 12 offices. How many ways to assign different offices?
- **Solution**: 
  - Assign office to Sanchez: 12 ways
  - Assign office to Patel (different from Sanchez's): 11 ways
  - Total: 12 × 11 = 132 ways

**Example 2: Chair Labeling**
- **Problem**: Chairs labeled with uppercase letter + positive integer ≤ 100. Maximum chairs?
- **Solution**:
  - Choose letter: 26 ways
  - Choose integer: 100 ways
  - Total: 26 × 100 = 2,600 chairs

**Example 3: Computer Ports**
- **Problem**: 32 computers, each with 24 ports. Total ports?
- **Solution**:
  - Choose computer: 32 ways
  - Choose port on selected computer: 24 ways
  - Total: 32 × 24 = 768 ports

**Example 4: Bit Strings**
- **Problem**: How many 7-bit strings exist?
- **Solution**:
  - Each bit: 2 choices (0 or 1)
  - 7 positions: 2⁷ = 128 different strings

**Example 5: License Plates**
- **Problem**: 3 uppercase letters + 3 digits, no restrictions
- **Solution**:
  - Each letter position: 26 choices
  - Each digit position: 10 choices
  - Total: 26³ × 10³ = 17,576,000 plates

**Example 6: Counting Functions**
- **Problem**: Functions from set with m elements to set with n elements
- **Solution**:
  - Each domain element maps to any codomain element
  - m domain elements, n choices each: nᵐ functions
  - Example: 3→5 elements gives 5³ = 125 functions

**Example 7: One-to-One Functions**
- **Problem**: Injective functions from m-element set to n-element set
- **Solution**:
  - If m > n: impossible (0 functions)
  - If m ≤ n:
    - First element: n choices
    - Second element: n-1 choices (can't repeat)
    - kth element: n-k+1 choices
  - Total: n(n-1)(n-2)...(n-m+1)
  - Example: 3→5 elements gives 5×4×3 = 60 functions

**Example 8: Telephone Numbering Plan**
- **Problem**: NANP telephone numbers with restrictions
- **Notation**: X = any digit (0-9), N = digits 2-9, Y = digits 0-1
- **Old Plan**: NYX-NNX-XXXX
  - Area codes (NYX): 8×2×10 = 160
  - Office codes (NNX): 8×8×10 = 640
  - Station codes (XXXX): 10⁴ = 10,000
  - Total: 160×640×10,000 = 1,024,000,000
- **New Plan**: NXX-NXX-XXXX
  - Area codes (NXX): 8×10×10 = 800
  - Office codes (NXX): 8×10×10 = 800
  - Station codes (XXXX): 10⁴ = 10,000
  - Total: 800×800×10,000 = 6,400,000,000

**Example 9: Nested Loop Analysis**
```
k := 0
for i₁ := 1 to n₁
  for i₂ := 1 to n₂
    ...
    for iₘ := 1 to nₘ
      k := k + 1
```
- **Solution**: Loop executes n₁×n₂×...×nₘ times
- **Final k value**: n₁×n₂×...×nₘ

**Example 10: Counting Subsets**
- **Problem**: Number of subsets of finite set S
- **Solution**: 
  - Each element: 2 choices (in subset or not)
  - |S| elements: 2^|S| subsets
  - Corresponds to bit strings of length |S|

**Example 11: DNA and Genomes**
- **DNA Bases**: A, C, G, T (4 possibilities)
- **RNA Bases**: A, C, G, U (4 possibilities)
- **Base Pairs**: DNA (A-T, C-G), RNA (A-U, C-G)
- **Amino Acid Encoding**:
  - 22 essential amino acids for humans
  - 2-base sequences: 4² = 16 < 22 (insufficient)
  - 3-base sequences: 4³ = 64 > 22 (sufficient)
- **Genome Complexity**:
  - Simple organisms: 10⁵ to 10⁷ links → at least 4^(10⁵) sequences
  - Complex organisms: 10⁸ to 10¹⁰ links → at least 4^(10⁸) sequences

### The Sum Rule

**Definition**: If a task can be done in n₁ ways OR n₂ ways, where no method from the first set equals any method from the second set, then there are n₁ + n₂ ways total.

**Extended Version**: For mutually exclusive methods with n₁, n₂, ..., nₘ ways respectively, total = n₁ + n₂ + ... + nₘ

#### Examples Using Sum Rule

**Example 12: Committee Representative**
- **Problem**: Choose either faculty member or math major student
- **Given**: 37 faculty, 83 math majors, no overlap
- **Solution**: 37 + 83 = 120 choices

**Example 13: Computer Projects**
- **Problem**: Choose from 3 lists with 23, 15, 19 projects respectively, no overlaps
- **Solution**: 23 + 15 + 19 = 57 total projects

**Example 14: Sequential Loop Analysis**
```
k := 0
for i₁ := 1 to n₁: k := k + 1
for i₂ := 1 to n₂: k := k + 1
...
for iₘ := 1 to nₘ: k := k + 1
```
- **Solution**: Final k = n₁ + n₂ + ... + nₘ

---

## 6.1.3 More Complex Counting Problems

### Combining Product and Sum Rules

**Example 15: BASIC Variable Names**
- **Rules**: 1-2 alphanumeric characters, start with letter, avoid 5 reserved strings
- **Solution**:
  - 1-character names (V₁): 26 (must be letters)
  - 2-character names (V₂): 26×36 - 5 = 931
  - Total: V₁ + V₂ = 26 + 931 = 957

**Example 16: Password Counting**
- **Rules**: 6-8 characters, uppercase letters + digits, ≥1 digit
- **Strategy**: Total strings - strings with no digits
- **Solutions**:
  - P₆ = 36⁶ - 26⁶ = 2,176,782,336 - 308,915,776 = 1,867,866,560
  - P₇ = 36⁷ - 26⁷ = 78,364,164,096 - 8,031,810,176 = 70,332,353,920
  - P₈ = 36⁸ - 26⁸ = 2,821,109,907,456 - 208,827,064,576 = 2,612,282,842,880
  - Total: P = P₆ + P₇ + P₈ = 2,684,483,063,360

**Example 17: IPv4 Address Counting**
- **Address Types**:
  - **Class A**: 0 + 7-bit netid + 24-bit hostid
    - Netids: 2⁷ - 1 = 127 (exclude 1111111)
    - Hostids: 2²⁴ - 2 = 16,777,214 (exclude all 0s, all 1s)
    - Total: 127 × 16,777,214 = 2,130,706,178
  - **Class B**: 10 + 14-bit netid + 16-bit hostid
    - Netids: 2¹⁴ = 16,384
    - Hostids: 2¹⁶ - 2 = 65,534
    - Total: 16,384 × 65,534 = 1,073,709,056
  - **Class C**: 110 + 21-bit netid + 8-bit hostid
    - Netids: 2²¹ = 2,097,152
    - Hostids: 2⁸ - 2 = 254
    - Total: 2,097,152 × 254 = 532,676,608
- **Grand Total**: 2,130,706,178 + 1,073,709,056 + 532,676,608 = 3,737,091,842

---

## 6.1.4 The Subtraction Rule (Inclusion-Exclusion for Two Sets)

**Definition**: If a task can be done in n₁ ways OR n₂ ways, but some ways are common to both, then total ways = n₁ + n₂ - (common ways)

**Set Formula**: |A₁ ∪ A₂| = |A₁| + |A₂| - |A₁ ∩ A₂|

### Examples Using Subtraction Rule

**Example 18: Bit Strings with Conditions**
- **Problem**: 8-bit strings that start with 1 OR end with 00
- **Solution**:
  - Start with 1: 2⁷ = 128 ways
  - End with 00: 2⁶ = 64 ways
  - Start with 1 AND end with 00: 2⁵ = 32 ways
  - Total: 128 + 64 - 32 = 160

**Example 19: Job Applicants**
- **Problem**: 350 applicants, 220 CS majors, 147 business majors, 51 both. How many neither?
- **Solution**:
  - CS or business: 220 + 147 - 51 = 316
  - Neither: 350 - 316 = 34

---

## 6.1.5 The Division Rule

**Definition**: If a task can be done in n ways, but every outcome corresponds to exactly d equivalent methods, then there are n/d distinct ways.

**Set Version**: If finite set A is union of n pairwise disjoint subsets each with d elements, then n = |A|/d

**Function Version**: If f: A → B is d-to-one (each y ∈ B has exactly d preimages), then |B| = |A|/d

### Examples Using Division Rule

**Example 20: Counting Cows**
- **Problem**: Automated system counts 572 cow legs. How many cows?
- **Solution**: Each cow has 4 legs, so 572/4 = 143 cows

**Example 21: Circular Table Seating**
- **Problem**: Seat 4 people around circular table (rotations equivalent)
- **Solution**:
  - Linear arrangements: 4! = 24
  - Rotational equivalence: 4 rotations per arrangement
  - Distinct arrangements: 24/4 = 6

---

## 6.1.6 Tree Diagrams

Tree diagrams visualize counting problems by representing choices as branches and outcomes as leaves.

### Examples Using Tree Diagrams

**Example 22: Bit Strings Without Consecutive 1s**
- **Problem**: 4-bit strings with no consecutive 1s
- **Tree Method**: Build tree showing valid choices at each position
- **Result**: 8 valid strings (0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010)

**Example 23: Best-of-5 Playoff**
- **Problem**: Playoff ends when team wins 3 games. How many ways can it proceed?
- **Tree Method**: Branch on game winners until someone reaches 3 wins
- **Result**: 20 different playoff sequences

**Example 24: T-Shirt Inventory**
- **Problem**: T-shirts in sizes S,M,L,XL,XXL with color restrictions
  - S,M,L: 4 colors each (W,R,G,B)
  - XL: 3 colors (R,G,B)
  - XXL: 2 colors (G,B)
- **Tree Method**: Branch by size, then by available colors
- **Result**: 4 + 4 + 4 + 3 + 2 = 17 different shirts

---

## Key Formulas Summary

1. **Product Rule**: n₁ × n₂ × ... × nₘ ways
2. **Sum Rule**: n₁ + n₂ + ... + nₘ ways (mutually exclusive)
3. **Subtraction Rule**: |A ∪ B| = |A| + |B| - |A ∩ B|
4. **Division Rule**: n/d ways (when d methods per outcome)
5. **Functions**: m→n elements gives nᵐ total, n(n-1)...(n-m+1) one-to-one
6. **Subsets**: 2ⁿ subsets of n-element set

## Problem-Solving Strategy

1. **Identify the structure**: Sequential (product) vs. alternatives (sum)
2. **Check for overlaps**: Use subtraction rule if needed
3. **Look for equivalences**: Apply division rule
4. **Complex problems**: Break into simpler parts
5. **Verify**: Use tree diagrams for small cases