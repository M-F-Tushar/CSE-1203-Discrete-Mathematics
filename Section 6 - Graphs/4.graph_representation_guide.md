# Complete Study Guide - Graph Representation and Isomorphism (Section 10.3)

## Table of Contents
1. [Introduction to Graph Representation](#introduction)
2. [Basic Graph Representation Methods](#basic-representation)
3. [Adjacency Lists](#adjacency-lists)
4. [Adjacency Matrices](#adjacency-matrices)
5. [Incidence Matrices](#incidence-matrices)
6. [Graph Isomorphism](#graph-isomorphism)
7. [Determining Isomorphism](#determining-isomorphism)
8. [Algorithms and Applications](#algorithms-applications)
9. [Detailed Examples and Solutions](#detailed-examples)

---

## Introduction to Graph Representation {#introduction}

### Why Multiple Representations Matter

Graph representation is crucial because:
- **Algorithmic Efficiency**: Different representations optimize different operations
- **Storage Requirements**: Some methods use less memory for sparse vs dense graphs
- **Computational Complexity**: Access time varies dramatically between methods
- **Problem-Specific Needs**: Certain algorithms work better with specific representations

### Overview of Representation Methods

1. **Edge Lists**: Simple enumeration of all edges
2. **Adjacency Lists**: For each vertex, list its neighbors
3. **Adjacency Matrices**: 2D matrix showing vertex connections
4. **Incidence Matrices**: 2D matrix showing vertex-edge relationships

---

## Basic Graph Representation Methods {#basic-representation}

### Edge List Representation

**Definition**: A simple list of all edges in the graph.

**Format for Undirected Graphs**: {v₁, v₂}, {v₃, v₄}, ...
**Format for Directed Graphs**: (v₁, v₂), (v₃, v₄), ...

**Advantages**:
- Simple and intuitive
- Minimal storage for sparse graphs
- Easy to add/remove edges

**Disadvantages**:
- Checking if edge exists requires O(|E|) time
- Finding neighbors of a vertex requires scanning entire list
- Inefficient for dense graphs

---

## Adjacency Lists {#adjacency-lists}

### Definition and Structure

**Adjacency List**: For each vertex v, maintain a list of all vertices adjacent to v.

**Storage Structure**:
```
Vertex → [List of Adjacent Vertices]
```

### Example 1: Simple Graph Adjacency Lists

**Given Graph**: Simple graph with vertices {a, b, c, d, e}

**Adjacency List Representation**:
```
a → [b, c, e]
b → [a]
c → [a, d, e]
d → [c, e]
e → [a, c, d]
```

**Analysis**:
- Vertex 'a' connects to vertices b, c, and e
- Vertex 'b' connects only to vertex a (pendant vertex)
- The lists are symmetric since the graph is undirected

### Example 2: Directed Graph Adjacency Lists

**Given Graph**: Directed graph with vertices {a, b, c, d, e}

**Adjacency List Representation**:
```
a → [b, c, d, e]  (a has edges TO b, c, d, e)
b → [b, d]        (b has edges TO b (loop) and d)
c → [a, c, e]     (c has edges TO a, c (loop), and e)
d → []            (d has no outgoing edges)
e → [b, c, d]     (e has edges TO b, c, and d)
```

**Key Differences from Undirected**:
- Lists are not symmetric
- Self-loops appear in vertex's own list
- Empty lists possible (vertices with no outgoing edges)

### Adjacency Lists: Complexity Analysis

**Space Complexity**:
- Undirected graph: O(|V| + 2|E|) = O(|V| + |E|)
- Directed graph: O(|V| + |E|)

**Time Complexity**:
- Check if edge exists: O(degree of vertex) = O(|V|) worst case
- Find all neighbors: O(degree of vertex)
- Add edge: O(1)
- Remove edge: O(degree of vertex)

**Best Use Cases**:
- Sparse graphs (few edges relative to vertices)
- When frequently iterating over neighbors
- When graph structure changes frequently

---

## Adjacency Matrices {#adjacency-matrices}

### Definition and Structure

**Adjacency Matrix**: An n×n matrix A where A[i,j] = 1 if there's an edge between vertices vᵢ and vⱼ, and 0 otherwise.

**Mathematical Definition**:
For simple graph G = (V, E) with vertices v₁, v₂, ..., vₙ:

```
aᵢⱼ = {
  1 if {vᵢ, vⱼ} ∈ E
  0 otherwise
}
```

### Example 3: Simple Graph Adjacency Matrix

**Given Graph**: Square graph with vertices a, b, c, d

**Vertex Ordering**: a, b, c, d

**Adjacency Matrix**:
```
    a  b  c  d
a [ 0  1  1  1 ]
b [ 1  0  1  0 ]
c [ 1  1  0  0 ]
d [ 1  0  0  0 ]
```

**Reading the Matrix**:
- Row 1 (vertex a): Connected to b, c, d (three 1's)
- Row 2 (vertex b): Connected to a, c (1's in columns 1,3)
- Diagonal is all 0's (no self-loops in simple graphs)
- Matrix is symmetric (undirected graph)

### Example 4: Constructing Graph from Adjacency Matrix

**Given Matrix**:
```
    a  b  c  d
a [ 0  1  1  0 ]
b [ 1  0  0  1 ]
c [ 1  0  0  1 ]
d [ 0  1  1  0 ]
```

**Graph Construction Process**:
1. Create vertices a, b, c, d
2. Add edge {a,b} (matrix[1,2] = 1)
3. Add edge {a,c} (matrix[1,3] = 1)
4. Add edge {b,d} (matrix[2,4] = 1)
5. Add edge {c,d} (matrix[3,4] = 1)

**Resulting Graph**: A 4-cycle: a-b-d-c-a

### Properties of Adjacency Matrices

**For Simple Graphs**:
- **Symmetric**: A[i,j] = A[j,i] (undirected edges)
- **Zero Diagonal**: A[i,i] = 0 (no self-loops)
- **Binary Entries**: Only 0's and 1's

**For Directed Graphs**:
- **Not Necessarily Symmetric**: A[i,j] ≠ A[j,i] generally
- **Possible Diagonal 1's**: Self-loops allowed

### Example 5: Pseudograph Adjacency Matrix

**Given Pseudograph**: Contains loops and multiple edges

**Adjacency Matrix**:
```
    a  b  c  d
a [ 0  3  0  2 ]
b [ 3  0  1  1 ]
c [ 0  1  1  2 ]
d [ 2  1  2  0 ]
```

**Interpretation**:
- A[1,2] = 3: Three edges between vertices a and b
- A[2,2] = 0: No loop at vertex b
- A[3,3] = 1: One loop at vertex c
- A[1,4] = 2: Two edges between vertices a and d

### Adjacency Matrix: Complexity Analysis

**Space Complexity**: Always O(|V|²)

**Time Complexity**:
- Check if edge exists: O(1)
- Find all neighbors: O(|V|)
- Add edge: O(1)
- Remove edge: O(1)

**Trade-offs**:

**Sparse Graphs** (few edges):
- **Disadvantage**: Wastes space (many 0's)
- **Memory Usage**: O(|V|²) regardless of edge count

**Dense Graphs** (many edges):
- **Advantage**: Efficient edge queries
- **Space Efficient**: When |E| ≈ |V|²/2

---

## Incidence Matrices {#incidence-matrices}

### Definition and Structure

**Incidence Matrix**: An n×m matrix M where rows represent vertices, columns represent edges.

**Mathematical Definition**:
```
mᵢⱼ = {
  1 if edge eⱼ is incident to vertex vᵢ
  0 otherwise
}
```

### Example 6: Basic Incidence Matrix

**Given Graph**: 5 vertices (v₁, v₂, v₃, v₄, v₅), 6 edges (e₁, e₂, e₃, e₄, e₅, e₆)

**Edge Definitions**:
- e₁: {v₁, v₄}
- e₂: {v₁, v₅}
- e₃: {v₂, v₃}
- e₄: {v₂, v₄}
- e₅: {v₂, v₅}
- e₆: {v₃, v₅}

**Incidence Matrix**:
```
     e₁ e₂ e₃ e₄ e₅ e₆
v₁ [ 1  1  0  0  0  0 ]
v₂ [ 0  0  1  1  1  0 ]
v₃ [ 0  0  1  0  0  1 ]
v₄ [ 1  0  0  1  0  0 ]
v₅ [ 0  1  0  0  1  1 ]
```

**Reading the Matrix**:
- Column e₁: Edge connects v₁ and v₄ (1's in rows 1 and 4)
- Each column has exactly two 1's (each edge connects two vertices)
- Row sums give vertex degrees

### Example 7: Pseudograph Incidence Matrix

**Special Cases in Incidence Matrices**:

**Multiple Edges**: Represented by identical columns
```
e₁ e₂ e₃
v₁ [1  1  0]  ← e₁ and e₂ are multiple edges between v₁ and v₂
v₂ [1  1  1]
v₃ [0  0  1]
```

**Loops**: Represented by columns with single 1
```
e₁ e₂
v₁ [1  0]  ← e₁ is a loop at v₁
v₂ [0  1]  ← e₂ is a loop at v₂
```

### Incidence Matrix Properties

**For Any Undirected Graph**:
- Each column has exactly two 1's (except loops)
- Loop columns have exactly one 1
- Row sum = degree of corresponding vertex
- Column sum = 2 (or 1 for loops)

**Space Complexity**: O(|V| × |E|)

**Use Cases**:
- Analyzing edge-vertex relationships
- Certain graph algorithms (network flows)
- When edge properties are important

---

## Graph Isomorphism {#graph-isomorphism}

### Fundamental Definition

**Graph Isomorphism**: Two simple graphs G₁ = (V₁, E₁) and G₂ = (V₂, E₂) are isomorphic if there exists a bijective function f: V₁ → V₂ such that:

{u, v} ∈ E₁ ⟺ {f(u), f(v)} ∈ E₂

**Intuitive Understanding**: Isomorphic graphs have identical structure but may have different vertex labels.

**Mathematical Properties**:
- Isomorphism is an equivalence relation
- Reflexive: Every graph is isomorphic to itself
- Symmetric: If G₁ ≅ G₂, then G₂ ≅ G₁
- Transitive: If G₁ ≅ G₂ and G₂ ≅ G₃, then G₁ ≅ G₃

### Example 8: Proving Isomorphism

**Given Graphs**: G and H with 4 vertices each

**Graph G vertices**: {u₁, u₂, u₃, u₄}
**Graph H vertices**: {v₁, v₂, v₃, v₄}

**Proposed Isomorphism**: f(u₁) = v₁, f(u₂) = v₄, f(u₃) = v₃, f(u₄) = v₂

**Verification Process**:
1. **Check Bijection**: f is one-to-one and onto ✓
2. **Verify Edge Preservation**:
   - Edge {u₁, u₂} in G → Check {f(u₁), f(u₂)} = {v₁, v₄} in H ✓
   - Edge {u₁, u₃} in G → Check {f(u₁), f(u₃)} = {v₁, v₃} in H ✓
   - Edge {u₂, u₄} in G → Check {f(u₂), f(u₄)} = {v₄, v₂} in H ✓
   - Edge {u₃, u₄} in G → Check {f(u₃), f(u₄)} = {v₃, v₂} in H ✓

**Conclusion**: Since f preserves all adjacencies, G ≅ H.

---

## Determining Isomorphism {#determining-isomorphism}

### Graph Invariants

**Definition**: Properties that are preserved under isomorphism.

**Essential Invariants**:
1. **Number of vertices**: |V₁| must equal |V₂|
2. **Number of edges**: |E₁| must equal |E₂|
3. **Degree sequence**: Must be identical
4. **Number of vertices of each degree**: Must match

### Example 9: Proving Non-Isomorphism

**Strategy**: Find an invariant that differs between the graphs.

**Analysis**:
- Both graphs have 5 vertices and 6 edges
- Graph G degree sequence: [2, 2, 2, 2, 2]
- Graph H degree sequence: [1, 2, 2, 2, 3]
- Since H has a degree-1 vertex and G doesn't, they cannot be isomorphic

**Key Insight**: Even one differing invariant proves non-isomorphism.

### Example 10: When Invariants Match But Graphs Differ

**Scenario**: Two graphs with identical basic invariants but different structure.

**Advanced Analysis Techniques**:
1. **Subgraph Analysis**: Examine induced subgraphs of vertices with specific degrees
2. **Path Analysis**: Check lengths of shortest paths between vertices
3. **Neighborhood Structure**: Analyze local connectivity patterns

**Detailed Solution**:
- Both graphs: 8 vertices, 10 edges, same degree sequence
- **Key Difference**: In G, degree-2 vertex 'a' is not adjacent to any other degree-2 vertex
- In H, every degree-2 vertex is adjacent to at least one other degree-2 vertex
- This structural difference proves non-isomorphism

### Example 11: Using Adjacency Matrices for Isomorphism

**Systematic Approach**:
1. **Identify Potential Correspondences**: Use degree constraints
2. **Build Mapping Incrementally**: Use adjacency relationships
3. **Verify with Matrix Comparison**: Compare reordered adjacency matrices

**Step-by-Step Process**:

**Step 1**: Identify vertices with unique properties
- deg(u₁) = 2 and u₁ not adjacent to other degree-2 vertices
- Only v₄ and v₆ in H have this property

**Step 2**: Build mapping using adjacency
- Choose f(u₁) = v₆
- Since u₂ is adjacent to u₁, f(u₂) must be adjacent to v₆
- Continue this logical process

**Step 3**: Verify with matrix comparison
```
Original AG:
    u₁ u₂ u₃ u₄ u₅ u₆
u₁ [0  1  0  1  0  0]
u₂ [1  0  1  0  0  1]
u₃ [0  1  0  1  0  0]
u₄ [1  0  1  0  1  0]
u₅ [0  0  0  1  0  1]
u₆ [0  1  0  0  1  0]

Reordered AH (using f):
    v₆ v₃ v₄ v₅ v₁ v₂
v₆ [0  1  0  1  0  0]
v₃ [1  0  1  0  0  1]
v₄ [0  1  0  1  0  0]
v₅ [1  0  1  0  1  0]
v₁ [0  0  0  1  0  1]
v₂ [0  1  0  0  1  0]
```

Since AG = AH (after reordering), the graphs are isomorphic.

---

## Algorithms and Applications {#algorithms-applications}

### Computational Complexity

**Classical Algorithms**:
- **Brute Force**: Check all n! possible vertex mappings
- **Time Complexity**: O(n! × n²) - exponential
- **Practical Limit**: ~10-15 vertices

**Modern Developments**:
- **Babai's Algorithm (2017)**: Quasi-polynomial time 2^O((log n)³)
- **NAUTY Software**: Practical tool for graphs up to 100 vertices
- **Average Case**: Many graphs can be solved in linear time

### NAUTY (No AUTomorphisms, Yes?)

**Capabilities**:
- Handles graphs with up to 100 vertices efficiently
- Finds graph automorphisms
- Canonical labeling for isomorphism testing
- Available as free software

**Performance**: Sub-second processing for most practical graphs

### Real-World Applications

#### Chemistry: Molecular Graphs

**Application**: Modeling chemical compounds
- **Vertices**: Atoms
- **Edges**: Chemical bonds
- **Isomorphism**: Determines if two compounds have same structure

**Structural Isomers**:
- Same molecular formula (e.g., C₄H₁₀)
- Different bonding structure
- Represented by non-isomorphic graphs

**Database Search**: Check if "new" compound already exists

#### Electronic Circuit Design

**Application**: Automated circuit design verification
- **Vertices**: Electronic components
- **Edges**: Connections between components
- **Isomorphism**: Verify layout matches original design

**Intellectual Property**:
- Detect unauthorized copying of circuit designs
- Find large isomorphic subgraphs between different chips

#### Other Applications

**Bioinformatics**:
- Protein structure comparison
- Metabolic pathway analysis

**Computer Vision**:
- Object recognition through graph matching
- Scene understanding

**Social Networks**:
- Community detection
- Network comparison

---

## Detailed Examples and Practice Problems {#detailed-examples}

### Complete Worked Examples

#### Example A: Creating All Three Representations

**Given Graph**: Triangle with additional pendant vertex

**Vertices**: {1, 2, 3, 4}
**Edges**: {{1,2}, {2,3}, {1,3}, {3,4}}

**1. Adjacency Lists**:
```
1 → [2, 3]
2 → [1, 3]
3 → [1, 2, 4]
4 → [3]
```

**2. Adjacency Matrix**:
```
    1  2  3  4
1 [ 0  1  1  0 ]
2 [ 1  0  1  0 ]
3 [ 1  1  0  1 ]
4 [ 0  0  1  0 ]
```

**3. Incidence Matrix**:
```
     e₁ e₂ e₃ e₄
1  [ 1  0  1  0 ]  ← e₁:{1,2}, e₃:{1,3}
2  [ 1  1  0  0 ]  ← e₁:{1,2}, e₂:{2,3}
3  [ 0  1  1  1 ]  ← e₂:{2,3}, e₃:{1,3}, e₄:{3,4}
4  [ 0  0  0  1 ]  ← e₄:{3,4}
```

#### Example B: Isomorphism Analysis

**Problem**: Determine if graphs G and H are isomorphic

**Initial Checks**:
1. Vertex count: G has 6, H has 6 ✓
2. Edge count: G has 8, H has 8 ✓
3. Degree sequences: Both [3,3,2,2,2,2] ✓

**Advanced Analysis**:
- Check subgraph induced by degree-3 vertices
- Analyze connectivity patterns
- Use systematic mapping approach

### Practice Problems with Solutions

#### Problem 1: Matrix to Graph Conversion

**Given Adjacency Matrix**:
```
[0 1 0 1]
[1 0 1 1]
[0 1 0 1]
[1 1 1 0]
```

**Solution Process**:
1. Label vertices: a, b, c, d
2. Read matrix entries:
   - Row 1: a connects to b, d
   - Row 2: b connects to a, c, d
   - Row 3: c connects to b, d
   - Row 4: d connects to a, b, c

**Resulting Graph**: Star-like graph with d as central vertex

#### Problem 2: Isomorphism Investigation

**Given**: Two 5-vertex graphs with different structures

**Analysis Strategy**:
1. Compare basic invariants
2. Check degree distributions
3. Analyze local neighborhoods
4. Look for distinguishing substructures

---

## Advanced Topics and Theorems

### Spectral Graph Theory Connection

**Adjacency Matrix Eigenvalues**: Provide powerful isomorphism invariants
- Isomorphic graphs have identical eigenvalue multisets
- Non-isomorphic graphs may have same eigenvalues (cospectral graphs)

### Automorphism Groups

**Graph Automorphism**: An isomorphism from a graph to itself
**Automorphism Group**: Set of all automorphisms with composition operation

**Applications**:
- Measuring graph symmetry
- Canonical form construction
- Algorithm optimization

### Complexity Theory Connections

**Graph Isomorphism Problem**:
- Not known to be in P (polynomial time)
- Not known to be NP-complete
- One of few problems in "NP-intermediate" class
- Major open problem in theoretical computer science

---

## Summary and Key Takeaways

### Representation Method Selection Guide

**Use Adjacency Lists When**:
- Graph is sparse (|E| << |V|²)
- Frequently iterating over neighbors
- Memory is limited
- Graph structure changes often

**Use Adjacency Matrices When**:
- Graph is dense (|E| ≈ |V|²/2)
- Frequently checking if specific edges exist
- Performing matrix operations
- Fixed graph structure

**Use Incidence Matrices When**:
- Edge properties are important
- Analyzing vertex-edge relationships
- Specific algorithms require this format

### Isomorphism Testing Strategy

**Quick Elimination**:
1. Check vertex count
2. Check edge count
3. Compare degree sequences
4. Check vertex degree distributions

**Detailed Analysis**:
1. Identify vertices with unique properties
2. Build potential mappings systematically
3. Verify with matrix comparison or direct edge checking
4. Use specialized software for large graphs

### Practical Applications Summary

**Graph representation and isomorphism concepts are fundamental to**:
- Database design and optimization
- Chemical informatics and drug discovery
- Electronic design automation
- Social network analysis
- Computer vision and pattern recognition
- Bioinformatics and computational biology

The choice of representation method significantly impacts algorithm performance and should be based on the specific application requirements and graph characteristics.