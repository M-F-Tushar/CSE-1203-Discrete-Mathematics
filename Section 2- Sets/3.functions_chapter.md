# Chapter 2.3: Functions - Complete Study Guide

## 2.3.1 Introduction to Functions

### What is a Function?

A **function** assigns to each element of one set exactly one element of another set. This is a fundamental concept in both mathematics and computer science.

**Real-world Example:** Consider assigning letter grades to students in a discrete mathematics class:
- Adams → A
- Chou → C  
- Goodfriend → B
- Rodriguez → A
- Stevens → F

This assignment is a function because each student gets exactly one grade.

### Formal Definition

**Definition 1:** Let A and B be nonempty sets. A function f from A to B is an assignment of exactly one element of B to each element of A. We write f(a) = b if b is the unique element of B assigned by the function f to the element a of A. If f is a function from A to B, we write f : A → B.

**Alternative Names:** Functions are sometimes called mappings or transformations.

### Ways to Specify Functions

Functions can be specified in several ways:
1. **Explicit assignments** (like the grade example above)
2. **Formulas** (like f(x) = x + 1)
3. **Computer programs**
4. **Relations** (as subsets of A × B)

### Key Terminology

**Definition 2:** If f is a function from A to B:
- **Domain of f:** The set A
- **Codomain of f:** The set B
- **Image of a:** If f(a) = b, then b is the image of a
- **Preimage of b:** If f(a) = b, then a is a preimage of b
- **Range (or Image) of f:** The set of all images of elements of A

**Important Note:** The codomain is the set of all *possible* values, while the range is the set of all *actual* values that the function produces.

### Examples with Detailed Analysis

**Example 1: Student Grades Function**
- Domain: {Adams, Chou, Goodfriend, Rodriguez, Stevens}
- Codomain: {A, B, C, D, F}
- Range: {A, B, C, F} (note: D is not in the range since no student received a D)

**Example 2: Age Function**
Given relation R = {(Abdul, 22), (Brenda, 24), (Carla, 21), (Desire, 22), (Eddie, 24), (Felicia, 22)}

Function f assigns each student their age:
- Domain: {Abdul, Brenda, Carla, Desire, Eddie, Felicia}
- Codomain: {positive integers less than 100}
- Range: {21, 22, 24}

**Example 3: Bit String Function**
f assigns the last two bits of a bit string of length ≥ 2
- f(11010) = 10
- Domain: all bit strings of length ≥ 2
- Codomain = Range = {00, 01, 10, 11}

**Example 4: Square Function**
f : Z → Z where f(x) = x²
- Domain: all integers
- Codomain: all integers
- Range: {0, 1, 4, 9, 16, ...} (perfect squares)

**Example 5: Programming Context**
```java
int floor(float real){...}
```
- Domain: real numbers (floats)
- Codomain: integers

### Function Operations

**Definition 3:** Let f₁ and f₂ be functions from A to R. Then:
- **(f₁ + f₂)(x) = f₁(x) + f₂(x)**
- **(f₁f₂)(x) = f₁(x)f₂(x)**

**Example 6:** If f₁(x) = x² and f₂(x) = x - x²:
- (f₁ + f₂)(x) = x² + (x - x²) = x
- (f₁f₂)(x) = x²(x - x²) = x³ - x⁴

### Image of a Subset

**Definition 4:** Let f be a function from A to B and S ⊆ A. The image of S under f is:
**f(S) = {t | ∃s∈S (t = f(s))} = {f(s) | s ∈ S}**

**Example 7:** 
- A = {a, b, c, d, e}, B = {1, 2, 3, 4}
- f(a) = 2, f(b) = 1, f(c) = 4, f(d) = 1, f(e) = 1
- For S = {b, c, d}: f(S) = {1, 4}

## 2.3.2 One-to-One and Onto Functions

### One-to-One Functions (Injections)

**Definition 5:** A function f is **one-to-one** (or **injective**) if and only if f(a) = f(b) implies a = b for all a and b in the domain of f.

**Equivalent formulation:** f is one-to-one ⟺ f(a) ≠ f(b) whenever a ≠ b

**In logical notation:** ∀a∀b(f(a) = f(b) → a = b)

#### Examples of One-to-One Functions

**Example 8:** f : {a, b, c, d} → {1, 2, 3, 4, 5} with f(a) = 4, f(b) = 5, f(c) = 1, f(d) = 3
- This is one-to-one because all function values are different

**Example 9:** f(x) = x² from Z to Z
- This is NOT one-to-one because f(1) = f(-1) = 1, but 1 ≠ -1

**Example 10:** f(x) = x + 1 from R to R
- This IS one-to-one: if x + 1 = y + 1, then x = y

**Example 11:** Job assignment function where each worker gets a different job
- This is one-to-one by definition

### Conditions Guaranteeing One-to-One

**Definition 6:** A function f with domain and codomain as subsets of real numbers is:
- **Increasing:** f(x) ≤ f(y) whenever x < y
- **Strictly increasing:** f(x) < f(y) whenever x < y
- **Decreasing:** f(x) ≥ f(y) whenever x < y
- **Strictly decreasing:** f(x) > f(y) whenever x < y

**Key Theorem:** Strictly increasing or strictly decreasing functions are one-to-one.

**Example 12:** f(x) = x² from R⁺ to R⁺ is strictly increasing
- If 0 < x < y, then x² < xy < y², so f(x) < f(y)
- Therefore, this function is one-to-one (unlike the version from R to R)

### Onto Functions (Surjections)

**Definition 7:** A function f from A to B is **onto** (or **surjective**) if and only if for every element b ∈ B there is an element a ∈ A with f(a) = b.

**In logical notation:** ∀y∃x(f(x) = y)

#### Examples of Onto Functions

**Example 13:** f : {a, b, c, d} → {1, 2, 3} with f(a) = 3, f(b) = 2, f(c) = 1, f(d) = 3
- This is onto because every element in {1, 2, 3} is mapped to by some element in the domain

**Example 14:** f(x) = x² from Z to Z
- This is NOT onto because no integer x satisfies x² = -1

**Example 15:** f(x) = x + 1 from Z to Z
- This IS onto: for any integer y, we can find x = y - 1 such that f(x) = y

**Example 16:** Job assignment where every job has a worker assigned
- This is onto by definition

### Bijections

**Definition 8:** A function f is a **bijection** (or **one-to-one correspondence**) if it is both one-to-one and onto. Such functions are called **bijective**.

**Example 17:** f : {a, b, c, d} → {1, 2, 3, 4} with f(a) = 4, f(b) = 2, f(c) = 1, f(d) = 3
- One-to-one: all values are different
- Onto: all elements of codomain are covered
- Therefore: bijection

### Visual Summary of Function Types

Consider these five correspondences:
1. **One-to-one, not onto:** Some codomain elements unmapped
2. **Onto, not one-to-one:** Some codomain elements have multiple preimages
3. **One-to-one and onto (bijection):** Perfect correspondence
4. **Neither one-to-one nor onto:** Multiple issues
5. **Not a function:** Some domain elements map to multiple values

### The Identity Function

**Example 18:** The identity function ιₐ : A → A is defined by ιₐ(x) = x for all x ∈ A
- This is always a bijection

### Proof Strategies Summary

To prove a function f : A → B is:

**Injective:** Show that if f(x) = f(y), then x = y
**Not injective:** Find x ≠ y such that f(x) = f(y)
**Surjective:** For arbitrary y ∈ B, find x ∈ A such that f(x) = y
**Not surjective:** Find y ∈ B such that f(x) ≠ y for all x ∈ A

## 2.3.3 Inverse Functions and Compositions

### Inverse Functions

**Definition 9:** Let f be a bijection from set A to set B. The **inverse function** of f is the function that assigns to each element b ∈ B the unique element a ∈ A such that f(a) = b. The inverse function is denoted f⁻¹.

**Key Points:**
- Only bijections have inverse functions
- f⁻¹(b) = a when f(a) = b
- Don't confuse f⁻¹ with 1/f

#### Examples of Inverse Functions

**Example 19:** f : {a, b, c} → {1, 2, 3} with f(a) = 2, f(b) = 3, f(c) = 1
- f is bijective, so f⁻¹ exists
- f⁻¹(1) = c, f⁻¹(2) = a, f⁻¹(3) = b

**Example 20:** f : Z → Z with f(x) = x + 1
- f is bijective (from previous examples)
- To find f⁻¹: if y = x + 1, then x = y - 1
- Therefore: f⁻¹(y) = y - 1

**Example 21:** f : R → R with f(x) = x²
- f is NOT bijective (not one-to-one since f(-2) = f(2) = 4)
- Therefore: f⁻¹ does not exist

**Example 22:** Restricting domains to create invertible functions
- f : R⁺∪{0} → R⁺∪{0} with f(x) = x²
- Now f is bijective:
  - One-to-one: if x² = y² and x,y ≥ 0, then x = y
  - Onto: every non-negative real has a non-negative square root
- Therefore: f⁻¹(y) = √y

### Function Composition

**Definition 10:** Let g : A → B and f : B → C. The **composition** of f and g, denoted f ∘ g, is the function from A to C defined by:
**(f ∘ g)(a) = f(g(a))**

**Important:** f ∘ g can only be defined if the range of g is a subset of the domain of f.

#### Examples of Function Composition

**Example 23:** 
- g : {a, b, c} → {a, b, c} with g(a) = b, g(b) = c, g(c) = a
- f : {a, b, c} → {1, 2, 3} with f(a) = 3, f(b) = 2, f(c) = 1

Computing f ∘ g:
- (f ∘ g)(a) = f(g(a)) = f(b) = 2
- (f ∘ g)(b) = f(g(b)) = f(c) = 1  
- (f ∘ g)(c) = f(g(c)) = f(a) = 3

Note: g ∘ f is not defined because the range of f is not a subset of the domain of g.

**Example 24:** f, g : Z → Z with f(x) = 2x + 3 and g(x) = 3x + 2
- (f ∘ g)(x) = f(g(x)) = f(3x + 2) = 2(3x + 2) + 3 = 6x + 7
- (g ∘ f)(x) = g(f(x)) = g(2x + 3) = 3(2x + 3) + 2 = 6x + 11

**Important:** Function composition is NOT commutative: f ∘ g ≠ g ∘ f in general.

**Example 25:** f : R → R⁺∪{0} with f(x) = x² and g : R⁺∪{0} → R with g(x) = √x
- (f ∘ g)(x) = f(g(x)) = f(√x) = (√x)² = x
- Domain of f ∘ g: R⁺∪{0}
- This gives us the identity function on non-negative reals

### Properties of Inverse Functions

For a bijection f : A → B with inverse f⁻¹ : B → A:
- **f⁻¹ ∘ f = ιₐ** (identity function on A)
- **f ∘ f⁻¹ = ιᵦ** (identity function on B)
- **(f⁻¹)⁻¹ = f**

## 2.3.4 The Graphs of Functions

**Definition 11:** Let f be a function from A to B. The **graph** of f is the set of ordered pairs:
**{(a, b) | a ∈ A and f(a) = b}**

The graph is the same as the relation determined by the function.

### Examples of Function Graphs

**Example 26:** f(n) = 2n + 1 from Z to Z
- Graph: {(n, 2n + 1) | n ∈ Z}
- Points: ..., (-2, -3), (-1, -1), (0, 1), (1, 3), (2, 5), ...

**Example 27:** f(x) = x² from Z to Z  
- Graph: {(x, x²) | x ∈ Z}
- Points: ..., (-2, 4), (-1, 1), (0, 0), (1, 1), (2, 4), ...

## 2.3.5 Some Important Functions

### Floor and Ceiling Functions

**Definition 12:** For any real number x:
- **Floor function ⌊x⌋:** the largest integer ≤ x
- **Ceiling function ⌈x⌉:** the smallest integer ≥ x

**Alternative name:** Floor function is also called the greatest integer function, sometimes denoted [x].

#### Examples of Floor and Ceiling

**Example 28:** 
- ⌊1/2⌋ = 0, ⌈1/2⌉ = 1
- ⌊-1/2⌋ = -1, ⌈-1/2⌉ = 0  
- ⌊3.1⌋ = 3, ⌈3.1⌉ = 4
- ⌊7⌋ = 7, ⌈7⌉ = 7

#### Practical Applications

**Example 29:** Data Storage
How many bytes are needed to store 100 bits?
- Each byte = 8 bits
- Need ⌈100/8⌉ = ⌈12.5⌉ = 13 bytes

**Example 30:** Network Transmission
How many 53-byte ATM cells can be transmitted in 1 minute at 500 kilobits/second?
- Total bits in 1 minute: 500,000 × 60 = 30,000,000 bits
- Bits per cell: 53 × 8 = 424 bits
- Number of cells: ⌊30,000,000/424⌋ = 70,754 cells

### Properties of Floor and Ceiling Functions

**Table 1: Key Properties** (n is integer, x is real)

**Basic Definitions:**
- (1a) ⌊x⌋ = n ⟺ n ≤ x < n + 1
- (1b) ⌈x⌉ = n ⟺ n - 1 < x ≤ n  
- (1c) ⌊x⌋ = n ⟺ x - 1 < n ≤ x
- (1d) ⌈x⌉ = n ⟺ x ≤ n < x + 1

**Bounds:**
- (2) x - 1 < ⌊x⌋ ≤ x ≤ ⌈x⌉ < x + 1

**Negation:**
- (3a) ⌊-x⌋ = -⌈x⌉
- (3b) ⌈-x⌉ = -⌊x⌋

**Translation:**
- (4a) ⌊x + n⌋ = ⌊x⌋ + n
- (4b) ⌈x + n⌉ = ⌈x⌉ + n

#### Proof Example for Property (4a)

**Proof of ⌊x + n⌋ = ⌊x⌋ + n:**
Let ⌊x⌋ = m. By property (1a): m ≤ x < m + 1
Adding n: m + n ≤ x + n < m + n + 1
By property (1a) again: ⌊x + n⌋ = m + n = ⌊x⌋ + n ∎

### Advanced Examples with Floor Functions

**Example 31:** Prove that ⌊2x⌋ = ⌊x⌋ + ⌊x + 1/2⌋

**Proof:** Let x = n + ε where n = ⌊x⌋ and 0 ≤ ε < 1.

**Case 1:** 0 ≤ ε < 1/2
- 2x = 2n + 2ε, so ⌊2x⌋ = 2n (since 0 ≤ 2ε < 1)
- x + 1/2 = n + (1/2 + ε), so ⌊x + 1/2⌋ = n (since 0 < 1/2 + ε < 1)
- Therefore: ⌊2x⌋ = 2n = n + n = ⌊x⌋ + ⌊x + 1/2⌋

**Case 2:** 1/2 ≤ ε < 1  
- 2x = 2n + 2ε = (2n + 1) + (2ε - 1), so ⌊2x⌋ = 2n + 1 (since 0 ≤ 2ε - 1 < 1)
- x + 1/2 = n + 1 + (ε - 1/2), so ⌊x + 1/2⌋ = n + 1 (since 0 ≤ ε - 1/2 < 1)
- Therefore: ⌊2x⌋ = 2n + 1 = n + (n + 1) = ⌊x⌋ + ⌊x + 1/2⌋ ∎

**Example 32:** Disprove ⌈x + y⌉ = ⌈x⌉ + ⌈y⌉

**Counterexample:** Let x = y = 1/2
- ⌈x + y⌉ = ⌈1⌉ = 1
- ⌈x⌉ + ⌈y⌉ = ⌈1/2⌉ + ⌈1/2⌉ = 1 + 1 = 2
- Since 1 ≠ 2, the statement is false.

### Other Important Functions

#### Factorial Function
**Definition:** f : N → Z⁺ where f(n) = n! = 1 · 2 · 3 · ... · n (and 0! = 1)

**Example 33:**
- 1! = 1
- 2! = 2  
- 6! = 720
- 20! = 2,432,902,008,176,640,000

**Stirling's Formula:** n! ∼ √(2πn)(n/e)ⁿ
(The symbol ∼ means "asymptotic to" - the ratio approaches 1 as n → ∞)

#### Logarithmic Functions
**Notation used in this text:**
- log x = log₂ x (base 2)
- logᵦ x (base b)  
- ln x (natural log, base e)

## 2.3.6 Partial Functions

### Motivation
Sometimes functions are not defined for all elements of their intended domain:
- Computer programs may not terminate or may overflow
- Mathematical functions like 1/x, √x, arcsin(x) have restricted domains
- Real-world functions like "youngest child" (undefined for childless couples)

**Definition 13:** A **partial function** f from A to B assigns to each element in a subset of A (called the **domain of definition**) a unique element in B. When the domain of definition equals A, f is called a **total function**.

**Notation:** We write f : A → B for both partial and total functions (context determines which).

**Example 34:** f : Z → R where f(n) = √n
- This is a partial function
- Domain of definition: non-negative integers
- f is undefined for negative integers

## Summary

This chapter covers the fundamental concepts of functions in discrete mathematics:

1. **Basic Definition:** Functions assign exactly one output to each input
2. **Types of Functions:**
   - Injective (one-to-one): different inputs → different outputs
   - Surjective (onto): every possible output is achieved  
   - Bijective: both injective and surjective
3. **Operations:** Composition and inverse functions
4. **Important Functions:** Floor, ceiling, factorial, logarithmic
5. **Extensions:** Partial functions for incomplete domains

These concepts are essential for understanding discrete structures, algorithm analysis, and computer science applications.